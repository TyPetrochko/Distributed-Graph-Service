#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from zope.interface import Interface, implements
from twisted.internet import defer
from thrift.transport import TTwisted

class Iface(Interface):
  def testVoid():
    """
    Prints "testVoid()" and returns nothing.
    """
    pass

  def testString(thing):
    """
    Prints 'testString("%s")' with thing as '%s'
    @param string thing - the string to print
    @return string - returns the string 'thing'

    Parameters:
     - thing
    """
    pass

  def testBool(thing):
    """
    Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
    @param bool  thing - the bool data to print
    @return bool  - returns the bool 'thing'

    Parameters:
     - thing
    """
    pass

  def testByte(thing):
    """
    Prints 'testByte("%d")' with thing as '%d'
    @param byte thing - the byte to print
    @return byte - returns the byte 'thing'

    Parameters:
     - thing
    """
    pass

  def testI32(thing):
    """
    Prints 'testI32("%d")' with thing as '%d'
    @param i32 thing - the i32 to print
    @return i32 - returns the i32 'thing'

    Parameters:
     - thing
    """
    pass

  def testI64(thing):
    """
    Prints 'testI64("%d")' with thing as '%d'
    @param i64 thing - the i64 to print
    @return i64 - returns the i64 'thing'

    Parameters:
     - thing
    """
    pass

  def testDouble(thing):
    """
    Prints 'testDouble("%f")' with thing as '%f'
    @param double thing - the double to print
    @return double - returns the double 'thing'

    Parameters:
     - thing
    """
    pass

  def testBinary(thing):
    """
    Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
    @param binary  thing - the binary data to print
    @return binary  - returns the binary 'thing'

    Parameters:
     - thing
    """
    pass

  def testStruct(thing):
    """
    Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
    @param Xtruct thing - the Xtruct to print
    @return Xtruct - returns the Xtruct 'thing'

    Parameters:
     - thing
    """
    pass

  def testNest(thing):
    """
    Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
    @param Xtruct2 thing - the Xtruct2 to print
    @return Xtruct2 - returns the Xtruct2 'thing'

    Parameters:
     - thing
    """
    pass

  def testMap(thing):
    """
    Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
     separated by commas and new lines
    @param map<i32,i32> thing - the map<i32,i32> to print
    @return map<i32,i32> - returns the map<i32,i32> 'thing'

    Parameters:
     - thing
    """
    pass

  def testStringMap(thing):
    """
    Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
     separated by commas and new lines
    @param map<string,string> thing - the map<string,string> to print
    @return map<string,string> - returns the map<string,string> 'thing'

    Parameters:
     - thing
    """
    pass

  def testSet(thing):
    """
    Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
     separated by commas and new lines
    @param set<i32> thing - the set<i32> to print
    @return set<i32> - returns the set<i32> 'thing'

    Parameters:
     - thing
    """
    pass

  def testList(thing):
    """
    Prints 'testList("{%s}")' where thing has been formatted into a string of  values
     separated by commas and new lines
    @param list<i32> thing - the list<i32> to print
    @return list<i32> - returns the list<i32> 'thing'

    Parameters:
     - thing
    """
    pass

  def testEnum(thing):
    """
    Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
    @param Numberz thing - the Numberz to print
    @return Numberz - returns the Numberz 'thing'

    Parameters:
     - thing
    """
    pass

  def testTypedef(thing):
    """
    Prints 'testTypedef("%d")' with thing as '%d'
    @param UserId thing - the UserId to print
    @return UserId - returns the UserId 'thing'

    Parameters:
     - thing
    """
    pass

  def testMapMap(hello):
    """
    Prints 'testMapMap("%d")' with hello as '%d'
    @param i32 hello - the i32 to print
    @return map<i32,map<i32,i32>> - returns a dictionary with these values:
      {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }

    Parameters:
     - hello
    """
    pass

  def testInsanity(argument):
    """
    So you think you've got this all worked, out eh?

    Creates a the returned map with these values and prints it out:
      { 1 => { 2 => argument,
               3 => argument,
             },
        2 => { 6 => <empty Insanity struct>, },
      }
    @return map<UserId, map<Numberz,Insanity>> - a map with the above values

    Parameters:
     - argument
    """
    pass

  def testMulti(arg0, arg1, arg2, arg3, arg4, arg5):
    """
    Prints 'testMulti()'
    @param byte arg0 -
    @param i32 arg1 -
    @param i64 arg2 -
    @param map<i16, string> arg3 -
    @param Numberz arg4 -
    @param UserId arg5 -
    @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
       and i64_thing = arg2

    Parameters:
     - arg0
     - arg1
     - arg2
     - arg3
     - arg4
     - arg5
    """
    pass

  def testException(arg):
    """
    Print 'testException(%s)' with arg as '%s'
    @param string arg - a string indication what type of exception to throw
    if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
    elsen if arg == "TException" throw TException
    else do not throw anything

    Parameters:
     - arg
    """
    pass

  def testMultiException(arg0, arg1):
    """
    Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
    @param string arg - a string indication what type of exception to throw
    if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
    elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and message = "This is an Xception2"
    else do not throw anything
    @return Xtruct - an Xtruct with string_thing = arg1

    Parameters:
     - arg0
     - arg1
    """
    pass

  def testOneway(secondsToSleep):
    """
    Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
    sleep 'secondsToSleep'
    Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
    @param i32 secondsToSleep - the number of seconds to sleep

    Parameters:
     - secondsToSleep
    """
    pass


class Client:
  implements(Iface)

  def __init__(self, transport, oprot_factory):
    self._transport = transport
    self._oprot_factory = oprot_factory
    self._seqid = 0
    self._reqs = {}

  def testVoid(self):
    """
    Prints "testVoid()" and returns nothing.
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testVoid)
    d.addCallbacks(
      callback=self.cb_send_testVoid,
      callbackArgs=(seqid,),
      errback=self.eb_send_testVoid,
      errbackArgs=(seqid,))
    return d

  def cb_send_testVoid(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testVoid(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testVoid(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testVoid', TMessageType.CALL, self._seqid)
    args = testVoid_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testVoid(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testVoid_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return d.callback(None)

  def testString(self, thing):
    """
    Prints 'testString("%s")' with thing as '%s'
    @param string thing - the string to print
    @return string - returns the string 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testString, thing)
    d.addCallbacks(
      callback=self.cb_send_testString,
      callbackArgs=(seqid,),
      errback=self.eb_send_testString,
      errbackArgs=(seqid,))
    return d

  def cb_send_testString(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testString(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testString(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testString', TMessageType.CALL, self._seqid)
    args = testString_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testString(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testString_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testString failed: unknown result"))

  def testBool(self, thing):
    """
    Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
    @param bool  thing - the bool data to print
    @return bool  - returns the bool 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testBool, thing)
    d.addCallbacks(
      callback=self.cb_send_testBool,
      callbackArgs=(seqid,),
      errback=self.eb_send_testBool,
      errbackArgs=(seqid,))
    return d

  def cb_send_testBool(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testBool(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testBool(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testBool', TMessageType.CALL, self._seqid)
    args = testBool_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testBool(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testBool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testBool failed: unknown result"))

  def testByte(self, thing):
    """
    Prints 'testByte("%d")' with thing as '%d'
    @param byte thing - the byte to print
    @return byte - returns the byte 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testByte, thing)
    d.addCallbacks(
      callback=self.cb_send_testByte,
      callbackArgs=(seqid,),
      errback=self.eb_send_testByte,
      errbackArgs=(seqid,))
    return d

  def cb_send_testByte(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testByte(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testByte(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testByte', TMessageType.CALL, self._seqid)
    args = testByte_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testByte(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testByte_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testByte failed: unknown result"))

  def testI32(self, thing):
    """
    Prints 'testI32("%d")' with thing as '%d'
    @param i32 thing - the i32 to print
    @return i32 - returns the i32 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testI32, thing)
    d.addCallbacks(
      callback=self.cb_send_testI32,
      callbackArgs=(seqid,),
      errback=self.eb_send_testI32,
      errbackArgs=(seqid,))
    return d

  def cb_send_testI32(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testI32(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testI32(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testI32', TMessageType.CALL, self._seqid)
    args = testI32_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testI32(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testI32_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testI32 failed: unknown result"))

  def testI64(self, thing):
    """
    Prints 'testI64("%d")' with thing as '%d'
    @param i64 thing - the i64 to print
    @return i64 - returns the i64 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testI64, thing)
    d.addCallbacks(
      callback=self.cb_send_testI64,
      callbackArgs=(seqid,),
      errback=self.eb_send_testI64,
      errbackArgs=(seqid,))
    return d

  def cb_send_testI64(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testI64(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testI64(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testI64', TMessageType.CALL, self._seqid)
    args = testI64_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testI64(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testI64_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testI64 failed: unknown result"))

  def testDouble(self, thing):
    """
    Prints 'testDouble("%f")' with thing as '%f'
    @param double thing - the double to print
    @return double - returns the double 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testDouble, thing)
    d.addCallbacks(
      callback=self.cb_send_testDouble,
      callbackArgs=(seqid,),
      errback=self.eb_send_testDouble,
      errbackArgs=(seqid,))
    return d

  def cb_send_testDouble(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testDouble(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testDouble(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testDouble', TMessageType.CALL, self._seqid)
    args = testDouble_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testDouble(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testDouble_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testDouble failed: unknown result"))

  def testBinary(self, thing):
    """
    Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
    @param binary  thing - the binary data to print
    @return binary  - returns the binary 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testBinary, thing)
    d.addCallbacks(
      callback=self.cb_send_testBinary,
      callbackArgs=(seqid,),
      errback=self.eb_send_testBinary,
      errbackArgs=(seqid,))
    return d

  def cb_send_testBinary(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testBinary(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testBinary(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testBinary', TMessageType.CALL, self._seqid)
    args = testBinary_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testBinary(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testBinary_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testBinary failed: unknown result"))

  def testStruct(self, thing):
    """
    Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
    @param Xtruct thing - the Xtruct to print
    @return Xtruct - returns the Xtruct 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testStruct, thing)
    d.addCallbacks(
      callback=self.cb_send_testStruct,
      callbackArgs=(seqid,),
      errback=self.eb_send_testStruct,
      errbackArgs=(seqid,))
    return d

  def cb_send_testStruct(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testStruct(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testStruct(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testStruct', TMessageType.CALL, self._seqid)
    args = testStruct_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testStruct(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testStruct_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testStruct failed: unknown result"))

  def testNest(self, thing):
    """
    Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
    @param Xtruct2 thing - the Xtruct2 to print
    @return Xtruct2 - returns the Xtruct2 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testNest, thing)
    d.addCallbacks(
      callback=self.cb_send_testNest,
      callbackArgs=(seqid,),
      errback=self.eb_send_testNest,
      errbackArgs=(seqid,))
    return d

  def cb_send_testNest(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testNest(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testNest(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testNest', TMessageType.CALL, self._seqid)
    args = testNest_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testNest(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testNest_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testNest failed: unknown result"))

  def testMap(self, thing):
    """
    Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
     separated by commas and new lines
    @param map<i32,i32> thing - the map<i32,i32> to print
    @return map<i32,i32> - returns the map<i32,i32> 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testMap, thing)
    d.addCallbacks(
      callback=self.cb_send_testMap,
      callbackArgs=(seqid,),
      errback=self.eb_send_testMap,
      errbackArgs=(seqid,))
    return d

  def cb_send_testMap(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testMap(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testMap(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMap', TMessageType.CALL, self._seqid)
    args = testMap_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMap(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testMap failed: unknown result"))

  def testStringMap(self, thing):
    """
    Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
     separated by commas and new lines
    @param map<string,string> thing - the map<string,string> to print
    @return map<string,string> - returns the map<string,string> 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testStringMap, thing)
    d.addCallbacks(
      callback=self.cb_send_testStringMap,
      callbackArgs=(seqid,),
      errback=self.eb_send_testStringMap,
      errbackArgs=(seqid,))
    return d

  def cb_send_testStringMap(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testStringMap(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testStringMap(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testStringMap', TMessageType.CALL, self._seqid)
    args = testStringMap_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testStringMap(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testStringMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testStringMap failed: unknown result"))

  def testSet(self, thing):
    """
    Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
     separated by commas and new lines
    @param set<i32> thing - the set<i32> to print
    @return set<i32> - returns the set<i32> 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testSet, thing)
    d.addCallbacks(
      callback=self.cb_send_testSet,
      callbackArgs=(seqid,),
      errback=self.eb_send_testSet,
      errbackArgs=(seqid,))
    return d

  def cb_send_testSet(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testSet(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testSet(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testSet', TMessageType.CALL, self._seqid)
    args = testSet_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testSet(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testSet failed: unknown result"))

  def testList(self, thing):
    """
    Prints 'testList("{%s}")' where thing has been formatted into a string of  values
     separated by commas and new lines
    @param list<i32> thing - the list<i32> to print
    @return list<i32> - returns the list<i32> 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testList, thing)
    d.addCallbacks(
      callback=self.cb_send_testList,
      callbackArgs=(seqid,),
      errback=self.eb_send_testList,
      errbackArgs=(seqid,))
    return d

  def cb_send_testList(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testList(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testList(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testList', TMessageType.CALL, self._seqid)
    args = testList_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testList(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testList failed: unknown result"))

  def testEnum(self, thing):
    """
    Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
    @param Numberz thing - the Numberz to print
    @return Numberz - returns the Numberz 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testEnum, thing)
    d.addCallbacks(
      callback=self.cb_send_testEnum,
      callbackArgs=(seqid,),
      errback=self.eb_send_testEnum,
      errbackArgs=(seqid,))
    return d

  def cb_send_testEnum(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testEnum(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testEnum(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testEnum', TMessageType.CALL, self._seqid)
    args = testEnum_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testEnum(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testEnum_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testEnum failed: unknown result"))

  def testTypedef(self, thing):
    """
    Prints 'testTypedef("%d")' with thing as '%d'
    @param UserId thing - the UserId to print
    @return UserId - returns the UserId 'thing'

    Parameters:
     - thing
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testTypedef, thing)
    d.addCallbacks(
      callback=self.cb_send_testTypedef,
      callbackArgs=(seqid,),
      errback=self.eb_send_testTypedef,
      errbackArgs=(seqid,))
    return d

  def cb_send_testTypedef(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testTypedef(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testTypedef(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testTypedef', TMessageType.CALL, self._seqid)
    args = testTypedef_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testTypedef(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testTypedef_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testTypedef failed: unknown result"))

  def testMapMap(self, hello):
    """
    Prints 'testMapMap("%d")' with hello as '%d'
    @param i32 hello - the i32 to print
    @return map<i32,map<i32,i32>> - returns a dictionary with these values:
      {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }

    Parameters:
     - hello
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testMapMap, hello)
    d.addCallbacks(
      callback=self.cb_send_testMapMap,
      callbackArgs=(seqid,),
      errback=self.eb_send_testMapMap,
      errbackArgs=(seqid,))
    return d

  def cb_send_testMapMap(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testMapMap(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testMapMap(self, hello):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMapMap', TMessageType.CALL, self._seqid)
    args = testMapMap_args()
    args.hello = hello
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMapMap(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testMapMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testMapMap failed: unknown result"))

  def testInsanity(self, argument):
    """
    So you think you've got this all worked, out eh?

    Creates a the returned map with these values and prints it out:
      { 1 => { 2 => argument,
               3 => argument,
             },
        2 => { 6 => <empty Insanity struct>, },
      }
    @return map<UserId, map<Numberz,Insanity>> - a map with the above values

    Parameters:
     - argument
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testInsanity, argument)
    d.addCallbacks(
      callback=self.cb_send_testInsanity,
      callbackArgs=(seqid,),
      errback=self.eb_send_testInsanity,
      errbackArgs=(seqid,))
    return d

  def cb_send_testInsanity(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testInsanity(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testInsanity(self, argument):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testInsanity', TMessageType.CALL, self._seqid)
    args = testInsanity_args()
    args.argument = argument
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testInsanity(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testInsanity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testInsanity failed: unknown result"))

  def testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
    """
    Prints 'testMulti()'
    @param byte arg0 -
    @param i32 arg1 -
    @param i64 arg2 -
    @param map<i16, string> arg3 -
    @param Numberz arg4 -
    @param UserId arg5 -
    @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
       and i64_thing = arg2

    Parameters:
     - arg0
     - arg1
     - arg2
     - arg3
     - arg4
     - arg5
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testMulti, arg0, arg1, arg2, arg3, arg4, arg5)
    d.addCallbacks(
      callback=self.cb_send_testMulti,
      callbackArgs=(seqid,),
      errback=self.eb_send_testMulti,
      errbackArgs=(seqid,))
    return d

  def cb_send_testMulti(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testMulti(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMulti', TMessageType.CALL, self._seqid)
    args = testMulti_args()
    args.arg0 = arg0
    args.arg1 = arg1
    args.arg2 = arg2
    args.arg3 = arg3
    args.arg4 = arg4
    args.arg5 = arg5
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMulti(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testMulti_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testMulti failed: unknown result"))

  def testException(self, arg):
    """
    Print 'testException(%s)' with arg as '%s'
    @param string arg - a string indication what type of exception to throw
    if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
    elsen if arg == "TException" throw TException
    else do not throw anything

    Parameters:
     - arg
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testException, arg)
    d.addCallbacks(
      callback=self.cb_send_testException,
      callbackArgs=(seqid,),
      errback=self.eb_send_testException,
      errbackArgs=(seqid,))
    return d

  def cb_send_testException(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testException(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testException(self, arg):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testException', TMessageType.CALL, self._seqid)
    args = testException_args()
    args.arg = arg
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testException(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testException_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.err1 is not None:
      return d.errback(result.err1)
    return d.callback(None)

  def testMultiException(self, arg0, arg1):
    """
    Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
    @param string arg - a string indication what type of exception to throw
    if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
    elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and message = "This is an Xception2"
    else do not throw anything
    @return Xtruct - an Xtruct with string_thing = arg1

    Parameters:
     - arg0
     - arg1
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testMultiException, arg0, arg1)
    d.addCallbacks(
      callback=self.cb_send_testMultiException,
      callbackArgs=(seqid,),
      errback=self.eb_send_testMultiException,
      errbackArgs=(seqid,))
    return d

  def cb_send_testMultiException(self, _, seqid):
    return self._reqs[seqid]

  def eb_send_testMultiException(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testMultiException(self, arg0, arg1):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMultiException', TMessageType.CALL, self._seqid)
    args = testMultiException_args()
    args.arg0 = arg0
    args.arg1 = arg1
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMultiException(self, iprot, mtype, rseqid):
    d = self._reqs.pop(rseqid)
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      return d.errback(x)
    result = testMultiException_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return d.callback(result.success)
    if result.err1 is not None:
      return d.errback(result.err1)
    if result.err2 is not None:
      return d.errback(result.err2)
    return d.errback(TApplicationException(TApplicationException.MISSING_RESULT, "testMultiException failed: unknown result"))

  def testOneway(self, secondsToSleep):
    """
    Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
    sleep 'secondsToSleep'
    Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
    @param i32 secondsToSleep - the number of seconds to sleep

    Parameters:
     - secondsToSleep
    """
    seqid = self._seqid = self._seqid + 1
    self._reqs[seqid] = defer.Deferred()

    d = defer.maybeDeferred(self.send_testOneway, secondsToSleep)
    d.addCallbacks(
      callback=self.cb_send_testOneway,
      callbackArgs=(seqid,),
      errback=self.eb_send_testOneway,
      errbackArgs=(seqid,))
    return d

  def cb_send_testOneway(self, _, seqid):
    d = self._reqs.pop(seqid)
    d.callback(None)
    return d

  def eb_send_testOneway(self, f, seqid):
    d = self._reqs.pop(seqid)
    d.errback(f)
    return d

  def send_testOneway(self, secondsToSleep):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testOneway', TMessageType.ONEWAY, self._seqid)
    args = testOneway_args()
    args.secondsToSleep = secondsToSleep
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

class Processor(TProcessor):
  implements(Iface)

  def __init__(self, handler):
    self._handler = Iface(handler)
    self._processMap = {}
    self._processMap["testVoid"] = Processor.process_testVoid
    self._processMap["testString"] = Processor.process_testString
    self._processMap["testBool"] = Processor.process_testBool
    self._processMap["testByte"] = Processor.process_testByte
    self._processMap["testI32"] = Processor.process_testI32
    self._processMap["testI64"] = Processor.process_testI64
    self._processMap["testDouble"] = Processor.process_testDouble
    self._processMap["testBinary"] = Processor.process_testBinary
    self._processMap["testStruct"] = Processor.process_testStruct
    self._processMap["testNest"] = Processor.process_testNest
    self._processMap["testMap"] = Processor.process_testMap
    self._processMap["testStringMap"] = Processor.process_testStringMap
    self._processMap["testSet"] = Processor.process_testSet
    self._processMap["testList"] = Processor.process_testList
    self._processMap["testEnum"] = Processor.process_testEnum
    self._processMap["testTypedef"] = Processor.process_testTypedef
    self._processMap["testMapMap"] = Processor.process_testMapMap
    self._processMap["testInsanity"] = Processor.process_testInsanity
    self._processMap["testMulti"] = Processor.process_testMulti
    self._processMap["testException"] = Processor.process_testException
    self._processMap["testMultiException"] = Processor.process_testMultiException
    self._processMap["testOneway"] = Processor.process_testOneway

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return defer.succeed(None)
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  def process_testVoid(self, seqid, iprot, oprot):
    args = testVoid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testVoid_result()
    d = defer.maybeDeferred(self._handler.testVoid, )
    d.addCallback(self.write_results_success_testVoid, result, seqid, oprot)
    return d

  def write_results_success_testVoid(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testVoid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testString(self, seqid, iprot, oprot):
    args = testString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testString_result()
    d = defer.maybeDeferred(self._handler.testString, args.thing)
    d.addCallback(self.write_results_success_testString, result, seqid, oprot)
    return d

  def write_results_success_testString(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testBool(self, seqid, iprot, oprot):
    args = testBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testBool_result()
    d = defer.maybeDeferred(self._handler.testBool, args.thing)
    d.addCallback(self.write_results_success_testBool, result, seqid, oprot)
    return d

  def write_results_success_testBool(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testByte(self, seqid, iprot, oprot):
    args = testByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testByte_result()
    d = defer.maybeDeferred(self._handler.testByte, args.thing)
    d.addCallback(self.write_results_success_testByte, result, seqid, oprot)
    return d

  def write_results_success_testByte(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testI32(self, seqid, iprot, oprot):
    args = testI32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testI32_result()
    d = defer.maybeDeferred(self._handler.testI32, args.thing)
    d.addCallback(self.write_results_success_testI32, result, seqid, oprot)
    return d

  def write_results_success_testI32(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testI32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testI64(self, seqid, iprot, oprot):
    args = testI64_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testI64_result()
    d = defer.maybeDeferred(self._handler.testI64, args.thing)
    d.addCallback(self.write_results_success_testI64, result, seqid, oprot)
    return d

  def write_results_success_testI64(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testI64", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testDouble(self, seqid, iprot, oprot):
    args = testDouble_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testDouble_result()
    d = defer.maybeDeferred(self._handler.testDouble, args.thing)
    d.addCallback(self.write_results_success_testDouble, result, seqid, oprot)
    return d

  def write_results_success_testDouble(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testDouble", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testBinary(self, seqid, iprot, oprot):
    args = testBinary_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testBinary_result()
    d = defer.maybeDeferred(self._handler.testBinary, args.thing)
    d.addCallback(self.write_results_success_testBinary, result, seqid, oprot)
    return d

  def write_results_success_testBinary(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testBinary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testStruct(self, seqid, iprot, oprot):
    args = testStruct_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testStruct_result()
    d = defer.maybeDeferred(self._handler.testStruct, args.thing)
    d.addCallback(self.write_results_success_testStruct, result, seqid, oprot)
    return d

  def write_results_success_testStruct(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testStruct", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testNest(self, seqid, iprot, oprot):
    args = testNest_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testNest_result()
    d = defer.maybeDeferred(self._handler.testNest, args.thing)
    d.addCallback(self.write_results_success_testNest, result, seqid, oprot)
    return d

  def write_results_success_testNest(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testNest", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testMap(self, seqid, iprot, oprot):
    args = testMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMap_result()
    d = defer.maybeDeferred(self._handler.testMap, args.thing)
    d.addCallback(self.write_results_success_testMap, result, seqid, oprot)
    return d

  def write_results_success_testMap(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testStringMap(self, seqid, iprot, oprot):
    args = testStringMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testStringMap_result()
    d = defer.maybeDeferred(self._handler.testStringMap, args.thing)
    d.addCallback(self.write_results_success_testStringMap, result, seqid, oprot)
    return d

  def write_results_success_testStringMap(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testStringMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testSet(self, seqid, iprot, oprot):
    args = testSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testSet_result()
    d = defer.maybeDeferred(self._handler.testSet, args.thing)
    d.addCallback(self.write_results_success_testSet, result, seqid, oprot)
    return d

  def write_results_success_testSet(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testList(self, seqid, iprot, oprot):
    args = testList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testList_result()
    d = defer.maybeDeferred(self._handler.testList, args.thing)
    d.addCallback(self.write_results_success_testList, result, seqid, oprot)
    return d

  def write_results_success_testList(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testEnum(self, seqid, iprot, oprot):
    args = testEnum_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testEnum_result()
    d = defer.maybeDeferred(self._handler.testEnum, args.thing)
    d.addCallback(self.write_results_success_testEnum, result, seqid, oprot)
    return d

  def write_results_success_testEnum(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testEnum", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testTypedef(self, seqid, iprot, oprot):
    args = testTypedef_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testTypedef_result()
    d = defer.maybeDeferred(self._handler.testTypedef, args.thing)
    d.addCallback(self.write_results_success_testTypedef, result, seqid, oprot)
    return d

  def write_results_success_testTypedef(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testTypedef", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testMapMap(self, seqid, iprot, oprot):
    args = testMapMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMapMap_result()
    d = defer.maybeDeferred(self._handler.testMapMap, args.hello)
    d.addCallback(self.write_results_success_testMapMap, result, seqid, oprot)
    return d

  def write_results_success_testMapMap(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testMapMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testInsanity(self, seqid, iprot, oprot):
    args = testInsanity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testInsanity_result()
    d = defer.maybeDeferred(self._handler.testInsanity, args.argument)
    d.addCallback(self.write_results_success_testInsanity, result, seqid, oprot)
    return d

  def write_results_success_testInsanity(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testInsanity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testMulti(self, seqid, iprot, oprot):
    args = testMulti_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMulti_result()
    d = defer.maybeDeferred(self._handler.testMulti, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5)
    d.addCallback(self.write_results_success_testMulti, result, seqid, oprot)
    return d

  def write_results_success_testMulti(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testMulti", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testException(self, seqid, iprot, oprot):
    args = testException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testException_result()
    d = defer.maybeDeferred(self._handler.testException, args.arg)
    d.addCallback(self.write_results_success_testException, result, seqid, oprot)
    d.addErrback(self.write_results_exception_testException, result, seqid, oprot)
    return d

  def write_results_success_testException(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_testException(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except Xception as err1:
      result.err1 = err1
    oprot.writeMessageBegin("testException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testMultiException(self, seqid, iprot, oprot):
    args = testMultiException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMultiException_result()
    d = defer.maybeDeferred(self._handler.testMultiException, args.arg0, args.arg1)
    d.addCallback(self.write_results_success_testMultiException, result, seqid, oprot)
    d.addErrback(self.write_results_exception_testMultiException, result, seqid, oprot)
    return d

  def write_results_success_testMultiException(self, success, result, seqid, oprot):
    result.success = success
    oprot.writeMessageBegin("testMultiException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def write_results_exception_testMultiException(self, error, result, seqid, oprot):
    try:
      error.raiseException()
    except Xception as err1:
      result.err1 = err1
    except Xception2 as err2:
      result.err2 = err2
    oprot.writeMessageBegin("testMultiException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_testOneway(self, seqid, iprot, oprot):
    args = testOneway_args()
    args.read(iprot)
    iprot.readMessageEnd()
    d = defer.maybeDeferred(self._handler.testOneway, args.secondsToSleep)
    return d


# HELPER FUNCTIONS AND STRUCTURES

class testVoid_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testVoid_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testVoid_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testVoid_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testString_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thing = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testString_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRING, 1)
      oprot.writeString(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBool_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.thing = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBool_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.BOOL, 1)
      oprot.writeBool(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testByte_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.thing = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testByte_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.BYTE, 1)
      oprot.writeByte(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI32_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.thing = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI32_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I32, 1)
      oprot.writeI32(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI64_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.thing = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI64_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I64, 1)
      oprot.writeI64(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI64_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI64_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testDouble_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.thing = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testDouble_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.DOUBLE, 1)
      oprot.writeDouble(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testDouble_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testDouble_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBinary_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thing = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBinary_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRING, 1)
      oprot.writeString(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBinary_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBinary_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStruct_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'thing', (Xtruct, Xtruct.thrift_spec), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.thing = Xtruct()
          self.thing.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStruct_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRUCT, 1)
      self.thing.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStruct_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStruct_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testNest_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'thing', (Xtruct2, Xtruct2.thrift_spec), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.thing = Xtruct2()
          self.thing.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testNest_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRUCT, 1)
      self.thing.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testNest_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct2, Xtruct2.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct2()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testNest_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMap_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'thing', (TType.I32,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.thing = {}
          (_ktype255, _vtype256, _size254 ) = iprot.readMapBegin()
          for _i258 in xrange(_size254):
            _key259 = iprot.readI32()
            _val260 = iprot.readI32()
            self.thing[_key259] = _val260
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMap_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.thing))
      for kiter261,viter262 in self.thing.items():
        oprot.writeI32(kiter261)
        oprot.writeI32(viter262)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype264, _vtype265, _size263 ) = iprot.readMapBegin()
          for _i267 in xrange(_size263):
            _key268 = iprot.readI32()
            _val269 = iprot.readI32()
            self.success[_key268] = _val269
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.success))
      for kiter270,viter271 in self.success.items():
        oprot.writeI32(kiter270)
        oprot.writeI32(viter271)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStringMap_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'thing', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.thing = {}
          (_ktype273, _vtype274, _size272 ) = iprot.readMapBegin()
          for _i276 in xrange(_size272):
            _key277 = iprot.readString()
            _val278 = iprot.readString()
            self.thing[_key277] = _val278
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStringMap_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.thing))
      for kiter279,viter280 in self.thing.items():
        oprot.writeString(kiter279)
        oprot.writeString(viter280)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStringMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype282, _vtype283, _size281 ) = iprot.readMapBegin()
          for _i285 in xrange(_size281):
            _key286 = iprot.readString()
            _val287 = iprot.readString()
            self.success[_key286] = _val287
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStringMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter288,viter289 in self.success.items():
        oprot.writeString(kiter288)
        oprot.writeString(viter289)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testSet_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'thing', (TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.thing = set()
          (_etype293, _size290) = iprot.readSetBegin()
          for _i294 in xrange(_size290):
            _elem295 = iprot.readI32()
            self.thing.add(_elem295)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testSet_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.SET, 1)
      oprot.writeSetBegin(TType.I32, len(self.thing))
      for iter296 in self.thing:
        oprot.writeI32(iter296)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testSet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype300, _size297) = iprot.readSetBegin()
          for _i301 in xrange(_size297):
            _elem302 = iprot.readI32()
            self.success.add(_elem302)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testSet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I32, len(self.success))
      for iter303 in self.success:
        oprot.writeI32(iter303)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testList_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'thing', (TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.thing = []
          (_etype307, _size304) = iprot.readListBegin()
          for _i308 in xrange(_size304):
            _elem309 = iprot.readI32()
            self.thing.append(_elem309)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testList_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.thing))
      for iter310 in self.thing:
        oprot.writeI32(iter310)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testList_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype314, _size311) = iprot.readListBegin()
          for _i315 in xrange(_size311):
            _elem316 = iprot.readI32()
            self.success.append(_elem316)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter317 in self.success:
        oprot.writeI32(iter317)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testEnum_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.thing = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testEnum_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I32, 1)
      oprot.writeI32(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testEnum_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testEnum_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTypedef_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.thing = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTypedef_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I64, 1)
      oprot.writeI64(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTypedef_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTypedef_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMapMap_args:
  """
  Attributes:
   - hello
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'hello', None, None, ), # 1
  )

  def __init__(self, hello=None,):
    self.hello = hello

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.hello = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMapMap_args')
    if self.hello is not None:
      oprot.writeFieldBegin('hello', TType.I32, 1)
      oprot.writeI32(self.hello)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hello)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMapMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.MAP,(TType.I32,None,TType.I32,None)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype319, _vtype320, _size318 ) = iprot.readMapBegin()
          for _i322 in xrange(_size318):
            _key323 = iprot.readI32()
            _val324 = {}
            (_ktype326, _vtype327, _size325 ) = iprot.readMapBegin()
            for _i329 in xrange(_size325):
              _key330 = iprot.readI32()
              _val331 = iprot.readI32()
              _val324[_key330] = _val331
            iprot.readMapEnd()
            self.success[_key323] = _val324
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMapMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.MAP, len(self.success))
      for kiter332,viter333 in self.success.items():
        oprot.writeI32(kiter332)
        oprot.writeMapBegin(TType.I32, TType.I32, len(viter333))
        for kiter334,viter335 in viter333.items():
          oprot.writeI32(kiter334)
          oprot.writeI32(viter335)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testInsanity_args:
  """
  Attributes:
   - argument
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'argument', (Insanity, Insanity.thrift_spec), None, ), # 1
  )

  def __init__(self, argument=None,):
    self.argument = argument

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.argument = Insanity()
          self.argument.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testInsanity_args')
    if self.argument is not None:
      oprot.writeFieldBegin('argument', TType.STRUCT, 1)
      self.argument.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.argument)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testInsanity_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.I32,None,TType.STRUCT,(Insanity, Insanity.thrift_spec))), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype337, _vtype338, _size336 ) = iprot.readMapBegin()
          for _i340 in xrange(_size336):
            _key341 = iprot.readI64()
            _val342 = {}
            (_ktype344, _vtype345, _size343 ) = iprot.readMapBegin()
            for _i347 in xrange(_size343):
              _key348 = iprot.readI32()
              _val349 = Insanity()
              _val349.read(iprot)
              _val342[_key348] = _val349
            iprot.readMapEnd()
            self.success[_key341] = _val342
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testInsanity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter350,viter351 in self.success.items():
        oprot.writeI64(kiter350)
        oprot.writeMapBegin(TType.I32, TType.STRUCT, len(viter351))
        for kiter352,viter353 in viter351.items():
          oprot.writeI32(kiter352)
          viter353.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMulti_args:
  """
  Attributes:
   - arg0
   - arg1
   - arg2
   - arg3
   - arg4
   - arg5
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'arg0', None, None, ), # 1
    (2, TType.I32, 'arg1', None, None, ), # 2
    (3, TType.I64, 'arg2', None, None, ), # 3
    (4, TType.MAP, 'arg3', (TType.I16,None,TType.STRING,None), None, ), # 4
    (5, TType.I32, 'arg4', None, None, ), # 5
    (6, TType.I64, 'arg5', None, None, ), # 6
  )

  def __init__(self, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None,):
    self.arg0 = arg0
    self.arg1 = arg1
    self.arg2 = arg2
    self.arg3 = arg3
    self.arg4 = arg4
    self.arg5 = arg5

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.arg0 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.arg1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.arg2 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.arg3 = {}
          (_ktype355, _vtype356, _size354 ) = iprot.readMapBegin()
          for _i358 in xrange(_size354):
            _key359 = iprot.readI16()
            _val360 = iprot.readString()
            self.arg3[_key359] = _val360
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.arg4 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.arg5 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMulti_args')
    if self.arg0 is not None:
      oprot.writeFieldBegin('arg0', TType.BYTE, 1)
      oprot.writeByte(self.arg0)
      oprot.writeFieldEnd()
    if self.arg1 is not None:
      oprot.writeFieldBegin('arg1', TType.I32, 2)
      oprot.writeI32(self.arg1)
      oprot.writeFieldEnd()
    if self.arg2 is not None:
      oprot.writeFieldBegin('arg2', TType.I64, 3)
      oprot.writeI64(self.arg2)
      oprot.writeFieldEnd()
    if self.arg3 is not None:
      oprot.writeFieldBegin('arg3', TType.MAP, 4)
      oprot.writeMapBegin(TType.I16, TType.STRING, len(self.arg3))
      for kiter361,viter362 in self.arg3.items():
        oprot.writeI16(kiter361)
        oprot.writeString(viter362)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.arg4 is not None:
      oprot.writeFieldBegin('arg4', TType.I32, 5)
      oprot.writeI32(self.arg4)
      oprot.writeFieldEnd()
    if self.arg5 is not None:
      oprot.writeFieldBegin('arg5', TType.I64, 6)
      oprot.writeI64(self.arg5)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg0)
    value = (value * 31) ^ hash(self.arg1)
    value = (value * 31) ^ hash(self.arg2)
    value = (value * 31) ^ hash(self.arg3)
    value = (value * 31) ^ hash(self.arg4)
    value = (value * 31) ^ hash(self.arg5)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMulti_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMulti_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testException_args:
  """
  Attributes:
   - arg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'arg', None, None, ), # 1
  )

  def __init__(self, arg=None,):
    self.arg = arg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.arg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testException_args')
    if self.arg is not None:
      oprot.writeFieldBegin('arg', TType.STRING, 1)
      oprot.writeString(self.arg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testException_result:
  """
  Attributes:
   - err1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err1', (Xception, Xception.thrift_spec), None, ), # 1
  )

  def __init__(self, err1=None,):
    self.err1 = err1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err1 = Xception()
          self.err1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testException_result')
    if self.err1 is not None:
      oprot.writeFieldBegin('err1', TType.STRUCT, 1)
      self.err1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.err1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMultiException_args:
  """
  Attributes:
   - arg0
   - arg1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'arg0', None, None, ), # 1
    (2, TType.STRING, 'arg1', None, None, ), # 2
  )

  def __init__(self, arg0=None, arg1=None,):
    self.arg0 = arg0
    self.arg1 = arg1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.arg0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.arg1 = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMultiException_args')
    if self.arg0 is not None:
      oprot.writeFieldBegin('arg0', TType.STRING, 1)
      oprot.writeString(self.arg0)
      oprot.writeFieldEnd()
    if self.arg1 is not None:
      oprot.writeFieldBegin('arg1', TType.STRING, 2)
      oprot.writeString(self.arg1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg0)
    value = (value * 31) ^ hash(self.arg1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMultiException_result:
  """
  Attributes:
   - success
   - err1
   - err2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'err1', (Xception, Xception.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'err2', (Xception2, Xception2.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err1=None, err2=None,):
    self.success = success
    self.err1 = err1
    self.err2 = err2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err1 = Xception()
          self.err1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.err2 = Xception2()
          self.err2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMultiException_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.err1 is not None:
      oprot.writeFieldBegin('err1', TType.STRUCT, 1)
      self.err1.write(oprot)
      oprot.writeFieldEnd()
    if self.err2 is not None:
      oprot.writeFieldBegin('err2', TType.STRUCT, 2)
      self.err2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.err1)
    value = (value * 31) ^ hash(self.err2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testOneway_args:
  """
  Attributes:
   - secondsToSleep
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'secondsToSleep', None, None, ), # 1
  )

  def __init__(self, secondsToSleep=None,):
    self.secondsToSleep = secondsToSleep

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.secondsToSleep = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testOneway_args')
    if self.secondsToSleep is not None:
      oprot.writeFieldBegin('secondsToSleep', TType.I32, 1)
      oprot.writeI32(self.secondsToSleep)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.secondsToSleep)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
